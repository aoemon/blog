<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>shishuai&#39;s&amp;nbsp;blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.shishuai.me/"/>
  <updated>2020-07-19T03:47:16.643Z</updated>
  <id>https://blog.shishuai.me/</id>
  
  <author>
    <name>时帅</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>为什么 Java 中的 hashCode() 使用 31 作为乘数？</title>
    <link href="https://blog.shishuai.me/posts/b79e7559/"/>
    <id>https://blog.shishuai.me/posts/b79e7559/</id>
    <published>2018-05-18T05:17:32.000Z</published>
    <updated>2020-07-19T03:47:16.643Z</updated>
    
    <content type="html"><![CDATA[<p>以 HashMap 为例，为了保证添加的元素是不可重复的，其 key 所在的类需要同时重写 <code>hashCode()</code> 和 <code>equals()</code> ，以实现元素相等规则。</p><p>在 Eclipse / IDEA 中，自定义类可以调用工具自动重写 <code>hashCode()</code> 和 <code>equals()</code> 。同时在重写 <code>hashCode()</code> 时，通常会选用 31 作为乘数参与哈希值的计算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = name != <span class="keyword">null</span> ? name.hashCode() : <span class="number">0</span>;</span><br><span class="line">    result = <span class="number">31</span> * result + age;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>String 中的 <code>hashCode()</code> 在计算每个字符时也会乘以 31，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由 for 循环可以推导出一个计算公式，在 <code>hashCode()</code> 注释中已经给出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]</span><br></pre></td></tr></table></figure><p>推导过程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">假设：n&#x3D;3</span><br><span class="line">i&#x3D;0 -&gt; h &#x3D; 31 * 0 + val[0]</span><br><span class="line">i&#x3D;1 -&gt; h &#x3D; 31 * (31 * 0 + val[0]) + val[1]</span><br><span class="line">i&#x3D;2 -&gt; h &#x3D; 31 * (31 * (31 * 0 + val[0]) + val[1]) + val[2]</span><br><span class="line">       h &#x3D; 31 * (31*31*0 + 31*val[0] + val[1]) + val[2]</span><br><span class="line">       h &#x3D; 31*31*31*0 + 31*31*val[0] + 31*val[1] + val[2]</span><br><span class="line">       h &#x3D; 31^(n-1)*val[0] + 31^(n-2)*val[1] + val[2]</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>问题是，为什么需要一个乘数，而且为 31？</strong></p><p>首先，选择一个乘数对哈希值进行膨胀是有必要的。理论上讲，如果数组长度很长，则哈希值越大，后续参与取模运算（位与运算）的二进制位就越多，则计算出的桶索引区间就越大，碰撞概率就越小；加之扰动函数 <code>hash()</code> 对哈希值的进一步优化，加入了高位计算，再次降低了碰撞的概率，从而提升 HashMap 的效率。</p><p>其次，选择 31 作为乘数主要有以下原因：</p><ul><li>31 是一个奇质数。</li><li>可以将乘法运算转换为开销更小的位移和减法运算：<code>31 * i == (i &lt;&lt; 5) - i</code> ，提高计算效率。多数虚拟机都会自动执行这种优化。</li></ul><p><strong>乘数要保证是奇数，这很重要</strong>。哈希值的目的是获得随机位（特别是低位，因为这些位通常使用更多），如果乘数是偶数，与 2 相乘等价于向左位移运算，最低位只能是 0，并且在乘法溢出时，总是会丢失最高有效位，这使得哈希值缺乏多样性，得到的值较少。但如果乘以奇数，最低位可以是 0 或 1，并且在乘法溢出时仍可保持多样性。</p><p><strong>使用质数的好处并不是很明显，但习惯上都使用质数来计算</strong>。如果用一个数字乘以质数，那么计算结果只能被数字本身和质数还有 1 来整除，从而减少冲突。</p><p>为了提高计算效率，2<sup>n</sup> 前后的奇质数可以很容易的将乘法运算转换为开销更小的位移和加减法运算，如：3、5、7、17、31、127 等。</p><p>以奇质数 3 为例，假设 n = 5，然后把 3 和 n 带入上面的计算公式，并仅计算公式中次数最高的那一项，结果是 3<sup>4</sup> = 81，数值较小。所以这里可以断定，当字符串长度不是很长时，用 3 做为乘数计算出的哈希值，数值不会很大。也就是说，哈希值会分布在一个较小的数值区间内，分布性不佳，最终可能会导致冲突率上升。</p><p>同时选择的乘数也不能太大，这会使计算出的哈希值很大。如果用 int 类型表示哈希值，结果很容易溢出，最终导致数值信息丢失（尽管数值信息丢失并不一定会导致冲突率上升）。</p><p>经过验证，31 作为乘数产生的冲突较少，分布相对较均匀，并可以很容易的转换为位移和减法运算：<code>i * 31 == i * (2^5 - 1) == (i &lt;&lt; 5) - i</code> 。</p><div class="note success"><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjk5MzA0L3doeS1kb2VzLWphdmFzLWhhc2hjb2RlLWluLXN0cmluZy11c2UtMzEtYXMtYS1tdWx0aXBsaWVy">Why does Java’s hashCode() in String use 31 as a multiplier?<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODU3NzU4Mi9vbi1pbnRlZ2VyLW11bHRpcGxpY2F0aW9uLW92ZXJmbG93LWFuZC1pbmZvcm1hdGlvbi1sb3Nz">On integer multiplication, overflow, and information loss<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxMDc5OTEyMw==">科普：为什么 String hashCode 方法选择数字 31 作为乘子<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzI0MzgxMDE2">java String hashCode() 设计的道理？<i class="fa fa-external-link-alt"></i></span></p></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以 HashMap 为例，为了保证添加的元素是不可重复的，其 key 所在的类需要同时重写 &lt;code&gt;hashCode()&lt;/code&gt; 和 &lt;code&gt;equals()&lt;/code&gt; ，以实现元素相等规则。&lt;/p&gt;
&lt;p&gt;在 Eclipse / IDEA 中，自定义类可以调用工具自动重写 &lt;code&gt;hashCode()&lt;/code&gt; 和 &lt;code&gt;equals()&lt;/code&gt; 。同时在重写 &lt;code&gt;hashCode()&lt;/code&gt; 时，通常会选用 31 作为乘数参与哈希值的计算：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;hashCode&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; result = name != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; ? name.hashCode() : &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    result = &lt;span class=&quot;number&quot;&gt;31&lt;/span&gt; * result + age;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; result;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;String 中的 &lt;code&gt;hashCode()&lt;/code&gt; 在计算每个字符时也会乘以 31，源码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;hashCode&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; h = hash;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (h == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; value.length &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; val[] = value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; value.length; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            h = &lt;span class=&quot;number&quot;&gt;31&lt;/span&gt; * h + val[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        hash = h;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; h;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;由 for 循环可以推导出一个计算公式，在 &lt;code&gt;hashCode()&lt;/code&gt; 注释中已经给出：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;推导过程如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;假设：n&amp;#x3D;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;i&amp;#x3D;0 -&amp;gt; h &amp;#x3D; 31 * 0 + val[0]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;i&amp;#x3D;1 -&amp;gt; h &amp;#x3D; 31 * (31 * 0 + val[0]) + val[1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;i&amp;#x3D;2 -&amp;gt; h &amp;#x3D; 31 * (31 * (31 * 0 + val[0]) + val[1]) + val[2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       h &amp;#x3D; 31 * (31*31*0 + 31*val[0] + val[1]) + val[2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       h &amp;#x3D; 31*31*31*0 + 31*31*val[0] + 31*val[1] + val[2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       h &amp;#x3D; 31^(n-1)*val[0] + 31^(n-2)*val[1] + val[2]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://blog.shishuai.me/categories/Java/"/>
    
    
      <category term="哈希表" scheme="https://blog.shishuai.me/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
</feed>
